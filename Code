local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "IMPORTANT", Description = "If any of the toggles are already green turn it off then turn it on for the feature to work black = off green = on"},
    {OutlineColor = Color3.fromRGB(80, 80, 80), Time = 8, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

local window = DrRayLibrary:Load("Rinns Hub", "Default")

local tab = DrRayLibrary.newTab("Main Tab", "ImageIdHere")

local aimbotEnabled = false
local aimbotCircleSize = 100
local aimbotCircle = nil
local teleportToSafePlaceEnabled = false
local originalPosition = nil

-- Create a really big part at the specified position
local bigPart = Instance.new("Part")
bigPart.Size = Vector3.new(100, 1, 100)
bigPart.Position = Vector3.new(-10487.8212890625, 16371.6865234375, -19404.552734375)
bigPart.Anchored = true
bigPart.Parent = game.Workspace

local autoBlockEnabled = false
local detectionMode = "360"  -- Default detection mode
local autoBlockRange = 50

tab.newToggle("Auto Block", "Auto Blocks Blockable skills for you", true, function(toggleState)
    autoBlockEnabled = toggleState
    if toggleState then
        print("On")
    else
        print("Off")
    end
end)

tab.newSlider("Auto Block Range Slider", "Changes the Range of the auto block", 50, false, function(num)
    autoBlockRange = num
    print(num)
end)

tab.newDropdown("Detection Mode", "Select one of these options!", {"360", "Front Facing"}, function(selectedOption)
    detectionMode = selectedOption
    print("Detection Mode set to:", selectedOption)
end)

-- Define the punch animations to detect
local punchAnimations = {
    ["10469493270"] = true,
    ["10469630950"] = true,
    ["10469639222"] = true,
    ["10469643643"] = true,
    ["13532562418"] = true,
    ["13491635433"] = true,
    ["13296577783"] = true,
    ["13295919399"] = true,
    ["13370310513"] = true,
    ["13390230973"] = true,
    ["13378751717"] = true,
    ["13378708199"] = true,
    ["14004222985"] = true,
    ["13997092940"] = true,
    ["14001963401"] = true,
    ["14136436157"] = true,
    ["15259161390"] = true,
    ["15240216931"] = true,
    ["15240176873"] = true,
    ["15162694192"] = true,
    ["16515503507"] = true,
    ["16515520431"] = true,
    ["16515448089"] = true,
    ["16552234590"] = true,
    ["17889458563"] = true,
    ["17889461810"] = true,
    ["17889471098"] = true,
    ["17889290569"] = true
}

-- Define the dash animations to detect
local dashAnimations = {
    ["10479335397"] = true,
    ["13380255751"] = true
}

-- Define the skill animations to detect with their respective delays
local skillAnimations = {
    ["10466974800"] = 1.8,  -- Satima Punches
    ["12534735382"] = 1.9,
    ["14046756619"] = 0.5,
    ["13376962659"] = 1.0,  -- Scatter Sonic
    ["12296882427"] = 0.4,
    ["12618292188"] = 0.6,
    ["12618271998"] = 0.6,
    ["13376869471"] = 0.5,
    ["17799224866"] = 0.9,  -- Bullet Barrage
    ["18179181663"] = 0.6,  -- Headfirst
    ["16515850153"] = 0.8,  -- Windstorm Fury
    ["16431491215"] = 0.7   -- Stone Coffin
}

-- Function to check if a player is within range
local function isPlayerInRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            return distance <= range
        end
    end
    return false
end

-- Function to check if a player is within the front-facing range
local function isPlayerInFrontFacingRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            if distance <= range then
                local direction = (targetRootPart.Position - rootPart.Position).Unit
                local lookVector = rootPart.CFrame.LookVector
                local angle = math.acos(direction:Dot(lookVector))
                return angle <= math.rad(90)  -- 90 degrees for front-facing detection
            end
        end
    end
    return false
end

-- Function to check if the local player is playing any of the specified animations
local function isLocalPlayerPlayingAnimation()
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
        local animId = animTrack.Animation.AnimationId:match("%d+$")
        if punchAnimations[animId] or dashAnimations[animId] or skillAnimations[animId] then
            return true
        end
    end
    return false
end

-- Function to detect animations
local function detectAnimations()
    local players = game:GetService("Players")

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer then
            local inRange = false
            if detectionMode == "360" then
                inRange = isPlayerInRange(player, autoBlockRange)
            elseif detectionMode == "Front Facing" then
                inRange = isPlayerInFrontFacingRange(player, autoBlockRange)
            end

            if inRange then
                local character = player.Character
                if character then
                    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
                        local animId = animTrack.Animation.AnimationId:match("%d+$")
                        if not isLocalPlayerPlayingAnimation() then
                            if punchAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.45)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif dashAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.90)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif skillAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(skillAnimations[animId])

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Connect the detection function to RunService
game:GetService("RunService").Heartbeat:Connect(function()
    if autoBlockEnabled then
        detectAnimations()
    end
end)

-- New Text Input for Combo Maker
tab.newInput("Combo Maker", "Enter your combo commands here (punch();wait(x);firstskill();secondskill();thirdskill();fourthskill();dash();downslam();moveforward();movebackward())", function(text)
    if text == "" then
        return
    end

    print("Entered text: " .. text)

    -- Create a new tool when input is finished
    local localPlayer = game.Players.LocalPlayer
    local tool = Instance.new("Tool")
    tool.Name = "Combo Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false

    -- Function to execute commands
    local function executeCommands()
        spawn(function()
            local toolNames = {
                ["firstskill()"] = {"Normal Punch", "Flowing Water", "Machine Gun Blows", "Flash Stirke", "Homerun", "Quick Slice", "Crushing Pull"},
                ["secondskill()"] = {"Atmos Cleave", "Windstorm Fury", "Ignition Burst", "Whirlwind Kick", "Beatdown", "Consecutive Punches", "Lethal Whirlwind Stream"},
                ["thirdskill()"] = {"Pinpoint Cut", "Stone Coffin", "Blitz Shot", "Scatter", "Grand Slam", "Shove", "Hunter's Grasp"},
                ["fourthskill()"] = {"Split Second Counter", "Expulsive Push", "Jet Dive", "Explosive Shuriken", "Foul Ball", "Uppercut", Head First", "Prey's Peril"}
            }

            for command in string.gmatch(text, "%S+") do
                if toolNames[command] then
                    for _, toolName in ipairs(toolNames[command]) do
                        local tool = localPlayer.Backpack:FindFirstChild(toolName) or localPlayer.Character:FindFirstChild(toolName)
                        if tool then
                            tool.Parent = localPlayer.Character
                            local args = {
                                [1] = {
                                    ["Goal"] = "LeftClick",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                            local argsRelease = {
                                [1] = {
                                    ["Goal"] = "LeftClickRelease",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                            tool.Parent = localPlayer.Backpack
                            break
                        end
                    end
                elseif command:match("^wait%((%d+%.?%d*)%)$") then
                    local waitTime = tonumber(command:match("%d+%.?%d*"))
                    wait(waitTime)
                elseif command == "punch()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.35)
                elseif command == "dash()" then
                    local args = {
                        [1] = {
                            ["Dash"] = Enum.KeyCode.W,
                            ["Key"] = Enum.KeyCode.Q,
                            ["Goal"] = "KeyPress"
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    function getNil(name, class) 
                        for _, v in pairs(getnilinstances()) do 
                            if v.ClassName == class and v.Name == name then 
                                return v
                            end 
                        end 
                    end

                    local args = {
                        [1] = {
                            ["Goal"] = "delete bv",
                            ["BV"] = getNil("moveme", "BodyVelocity")
                        }
                    }

                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    wait(0.85)
                elseif command == "downslam()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.33)

                    game.Players.LocalPlayer.Character.Humanoid.Jump = true
                    wait(0.15)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.1)

                elseif command == "moveforward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5)
                    end
                elseif command == "movebackward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
                    end
                end
            end
        end)
    end

    tool.Activated:Connect(executeCommands)

    tool.Parent = localPlayer.Backpack
end)

local Targets = {"All"} -- "All", "Target Name", "arian_was_here"

local Players = game:GetService("Players")
local Player = Players.LocalPlayer

local AllBool = false
local LoopFling = false

local GetPlayer = function(Name)
    Name = Name:lower()
    if Name == "all" or Name == "others" then
        AllBool = true
        return
    elseif Name == "random" then
        local GetPlayers = Players:GetPlayers()
        if table.find(GetPlayers, Player) then table.remove(GetPlayers, table.find(GetPlayers, Player)) end
        return GetPlayers[math.random(#GetPlayers)]
    elseif Name ~= "random" and Name ~= "all" and Name ~= "others" then
        for _, x in next, Players:GetPlayers() do
            if x ~= Player then
                if x.Name:lower():match("^" .. Name) then
                    return x
                elseif x.DisplayName:lower():match("^" .. Name) then
                    return x
                end
            end
        end
    else
        return
    end
end

local SkidFling = function(TargetPlayer)
    local Character = Player.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart

    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle

    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessory and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end

    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().OldPos = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit and not AllBool then
            return
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end

        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end

        local SFBasePart = function(BasePart)
            local TimeToWait = 2
            local Time = tick()
            local Angle = 0

            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()

                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end

        workspace.FallenPartsDestroyHeight = 0 / 0

        local BV = Instance.new("BodyVelocity")
        BV.Name = "EpixVel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1 / 0, 1 / 0, 1 / 0)

        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return
        end

        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid

        repeat
            RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return
    end
end

local FlingAllPlayers = function()
    for _, x in next, Players:GetPlayers() do
        SkidFling(x)
    end
end

local LoopFlingAllPlayers = function()
    while LoopFling do
        FlingAllPlayers()
        task.wait(5) -- Adjust this delay as needed
        if not LoopFling then
            break
        end
    end
end

tab.newButton("Fling All", "Flings Everyone in the game only use this again after it's over", function()
    FlingAllPlayers()
end)

tab.newToggle("Loop fling all", "Loops Fling all", true, function(toggleState)
    LoopFling = toggleState
    if LoopFling then
        coroutine.wrap(LoopFlingAllPlayers)()
    end
end)

tab.newInput("Fling Player", "Flings A Specific Player", function(text)
    local targetPlayer = GetPlayer(text)
    if targetPlayer then
        SkidFling(targetPlayer)
    else
        print("Player not found")
    end
end)

-- Toggle for Aimbot
tab.newToggle("Aimbot", "Enables Aimbot to target the nearest player", false, function(toggleState)
    aimbotEnabled = toggleState
    if aimbotEnabled then
        local camera = game.Workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer

        local circle = Drawing.new("Circle")
        circle.Thickness = 2
        circle.Transparency = 0.4
        circle.Color = Color3.fromRGB(255, 255, 255)
        circle.NumSides = 100
        circle.Filled = false

        game:GetService("RunService").RenderStepped:Connect(function()
            if aimbotEnabled then
                circle.Visible = true
                circle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                circle.Radius = aimbotCircleSize

                local closestPlayer = nil
                local shortestDistance = aimbotCircleSize

                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local screenPoint, onScreen = camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - circle.Position).magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end

                if closestPlayer then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, closestPlayer.Character.HumanoidRootPart.Position)
                end
            else
                circle.Visible = false
            end
        end)
    end
end)

-- Slider for Aimbot Circle Size
tab.newSlider("Aimbot Circle Size", "Change the size of the Aimbot circle", 450,
false, function(value)
    aimbotCircleSize = value
end)

-- Toggle for Teleport to Safe Place
tab.newToggle("Teleport to Safe Place When low", "Teleports you to a safe place when your low", false, function(toggleState)
    teleportToSafePlaceEnabled = toggleState
    local player = game.Players.LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

    local function checkHealth()
        if teleportToSafePlaceEnabled and humanoid and humanoid.Health <= 15 then
            if not originalPosition then
                originalPosition = player.Character.PrimaryPart.Position
            end
            local safePlace = Vector3.new(-10492.9931640625, 16379.8828125, -19407.078125)
            player.Character:SetPrimaryPartCFrame(CFrame.new(safePlace))
        elseif originalPosition and humanoid and humanoid.Health >= 30 then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end

    local healthCheckConnection

    if teleportToSafePlaceEnabled then
        healthCheckConnection = game:GetService("RunService").RenderStepped:Connect(checkHealth)
        checkHealth()
    else
        if healthCheckConnection then
            healthCheckConnection:Disconnect()
            healthCheckConnection = nil
        end
        if originalPosition then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end
end)

-- No Stun Button
tab.newButton("No Stun", "Disables or reduces stun effects only click once", function()
    local function isNumber(str)
        return tonumber(str) ~= nil or str == 'inf'
    end

    local tspeed = 0.3
    local hb = game:GetService("RunService").Heartbeat
    local tpwalking = true
    local player = game:GetService("Players")
    local lplr = player.LocalPlayer
    local chr = lplr.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
        if hum.MoveDirection.Magnitude > 0 then
            if tspeed and isNumber(tspeed) then
                chr:TranslateBy(hum.MoveDirection * tonumber(tspeed))
            else
                chr:TranslateBy(hum.MoveDirection)
            end
        end
    end
end)

-- settings
local settings = {
    defaultcolor = Color3.fromRGB(255, 0, 0),
    teamcheck = false,
    teamcolor = true,
    boxESPEnabled = false,
    tracersEnabled = false
};

-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");

-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i, v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};

local function createEsp(player)
    local drawings = {};

    drawings.box = newDrawing("Square");
    drawings.box.Thickness = 1;
    drawings.box.Filled = false;
    drawings.box.Color = settings.defaultcolor;
    drawings.box.Visible = false;
    drawings.box.ZIndex = 2;

    drawings.boxoutline = newDrawing("Square");
    drawings.boxoutline.Thickness = 2; -- Making the outline thinner
    drawings.boxoutline.Filled = false;
    drawings.boxoutline.Color = newColor3();
    drawings.boxoutline.Visible = false;
    drawings.boxoutline.ZIndex = 1;

    drawings.tracer = newDrawing("Line");
    drawings.tracer.Thickness = 1;
    drawings.tracer.Color = settings.defaultcolor;
    drawings.tracer.Visible = false;
    drawings.tracer.ZIndex = 1;

    espCache[player] = drawings;
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove();
        end
        espCache[player] = nil;
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character;
    if character then
        local head = character:FindFirstChild("Head");
        local rootPart = character:FindFirstChild("HumanoidRootPart");
        if head and rootPart then
            local headPos, headVisible = wtvp(head.Position);
            local rootPos, rootVisible = wtvp(rootPart.Position);
            local visible = headVisible and rootVisible;
            
            esp.box.Visible = visible and settings.boxESPEnabled;
            esp.boxoutline.Visible = visible and settings.boxESPEnabled;
            esp.tracer.Visible = visible and settings.tracersEnabled;

            if visible then
                local min = character:GetModelCFrame().Position - Vector3.new(2, 3, 0);
                local max = character:GetModelCFrame().Position + Vector3.new(2, 3, 0);
                local minPos, minVisible = wtvp(min);
                local maxPos, maxVisible = wtvp(max);
                if minVisible and maxVisible then
                    local width = math.abs(minPos.X - maxPos.X);
                    local height = math.abs(minPos.Y - maxPos.Y);
                    local x, y = round(minPos.X, minPos.Y);

                    esp.box.Size = newVector2(width, height);
                    esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
                    esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;

                    esp.boxoutline.Size = esp.box.Size;
                    esp.boxoutline.Position = esp.box.Position;

                    local localHead = localPlayer.Character and localPlayer.Character:FindFirstChild("Head");
                    if localHead then
                        local localHeadPos = wtvp(localHead.Position);
                        esp.tracer.From = localHeadPos;
                        esp.tracer.To = headPos;
                        esp.tracer.Color = esp.box.Color;
                    end
                end
            end
        end
    else
        esp.box.Visible = false;
        esp.boxoutline.Visible = false;
        esp.tracer.Visible = false;
    end
end

local function rainbowColorTransition()
    local t = tick() * 0.1
    return Color3.fromHSV(t % 1, 1, 1)
end

-- main
for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player);
    end
end

players.PlayerAdded:Connect(function(player)
    createEsp(player);
end);

players.PlayerRemoving:Connect(function(player)
    removeEsp(player);
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then
            continue;
        end

        if drawings and player ~= localPlayer then
            updateEsp(player, drawings);
            drawings.box.Color = rainbowColorTransition();
            drawings.tracer.Color = drawings.box.Color;
        end
    end
end)

-- GUI integration
local tab = DrRayLibrary.newTab("Esp Tab", "ImageIdHere")

tab.newToggle("Box Esp", "Draws a box around every player", true, function(toggleState)
    settings.boxESPEnabled = toggleState
end)

tab.newToggle("Tracers Esp", "Draws a line to every player", true, function(toggleState)
    settings.tracersEnabled = toggleState
end)

local tab = DrRayLibrary.newTab("Misc Tab", "ImageIdHere")

tab.newButton("Change To The Strongest Hero", "Changes your character to the strongest hero", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Bald"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Hero Hunter", "Changes your character to Hero Hunter", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Hunter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Destructive Cyborg", "Changes your character to Destructive Cyborg", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Cyborg"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Deadly Ninja", "Changes your character to Deadly Ninja", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Ninja"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Brutal Demon", "Changes your character to Brutal Demon", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Batter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Blade Master", "Changes your character to Blade Master", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Blade"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Wild Psychic", "Changes your character to Wild Psychic", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Esper"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

-- Button for Rejoin
tab.newButton("Rejoin", "Rejoin the game", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end)

-- Button for Serverhop
tab.newButton("Serverhop", "Hop to another server", function()
    local ts = game:GetService("TeleportService")
    local http = game:GetService("HttpService")
    local servers = {}
    local function listServers(cursor)
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        if cursor then
            url = url .. "&cursor=" .. cursor
        end
        local response = game:HttpGet(url)
        return http:JSONDecode(response)
    end
    local serverData = listServers()
    for _, server in ipairs(serverData.data) do
        if server.playing < server.maxPlayers then
            table.insert(servers, server.id)
        end
    end
    if #servers > 0 then
        ts:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
    else
warn("No available servers found.")
    end
end)
