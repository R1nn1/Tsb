local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()

local window = DrRayLibrary:Load("Rinns Hub", "Default")

local tab = DrRayLibrary.newTab("Main Tab", "ImageIdHere")

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "IMPORTANT", Description = "If any of the toggles are already on turn it off and turn it back on again black = off green = on"},
    {OutlineColor = Color3.fromRGB(80, 80, 80),Time = 10, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

-- List of animation IDs
local animationIDs = {
    ["rbxassetid://10468665991"] = true,
    ["rbxassetid://10466974800"] = true,
    ["rbxassetid://10471336737"] = true,
    ["rbxassetid://12510170988"] = true,
    ["rbxassetid://12272894215"] = true,
    ["rbxassetid://12296882427"] = true,
    ["rbxassetid://12307656616"] = true,
    ["rbxassetid://12351854556"] = true,
    ["rbxassetid://12534735382"] = true,
    ["rbxassetid://12502664044"] = true,
    ["rbxassetid://12509505723"] = true,
    ["rbxassetid://12618292188"] = true,
    ["rbxassetid://12684185971"] = true,
    ["rbxassetid://13376869471"] = true,
    ["rbxassetid://13294790250"] = true,
    ["rbxassetid://13376962659"] = true,
    ["rbxassetid://13501296372"] = true,
    ["rbxassetid://14004235777"] = true,
    ["rbxassetid://14003607057"] = true,
    ["rbxassetid://14046756619"] = true,
    ["rbxassetid://14048349132"] = true,
    ["rbxassetid://14299135500"] = true,
    ["rbxassetid://14967219354"] = true,
    ["rbxassetid://14357997687"] = true,
    ["rbxassetid://14357943487"] = true,
    ["rbxassetid://15290930205"] = true,
    ["rbxassetid://15145462680"] = true,
    ["rbxassetid://15295895753"] = true,
    ["rbxassetid://15311685628"] = true,
    ["rbxassetid://16139108718"] = true,
    ["rbxassetid://16139402582"] = true,
    ["rbxassetid://16515850153"] = true,
    ["rbxassetid://16431491215"] = true,
    ["rbxassetid://16597322398"] = true,
    ["rbxassetid://10469493270"] = true,
    ["rbxassetid://10469630950"] = true,
    ["rbxassetid://10469639222"] = true,
    ["rbxassetid://10469643643"] = true,
    ["rbxassetid://13532562418"] = true,
    ["rbxassetid://13491635433"] = true,
    ["rbxassetid://13296577783"] = true,
    ["rbxassetid://13295919399"] = true,
    ["rbxassetid://13370310513"] = true,
    ["rbxassetid://13390230973"] = true,
    ["rbxassetid://13378751717"] = true,
    ["rbxassetid://13378708199"] = true,
    ["rbxassetid://14004222985"] = true,
    ["rbxassetid://13997092940"] = true,
    ["rbxassetid://14001963401"] = true,
    ["rbxassetid://14136436157"] = true,
    ["rbxassetid://15259161390"] = true,
    ["rbxassetid://15240216931"] = true,
    ["rbxassetid://15240176873"] = true,
    ["rbxassetid://15162694192"] = true,
    ["rbxassetid://16515503507"] = true,
    ["rbxassetid://16515520431"] = true,
    ["rbxassetid://16515448089"] = true,
    ["rbxassetid://16552234590"] = true,
    ["rbxassetid://17889458563"] = true,
    ["rbxassetid://17889461810"] = true,
    ["rbxassetid://17889471098"] = true,
    ["rbxassetid://17889290569"] = true,
    ["rbxassetid://10479335397"] = true,
    ["rbxassetid://13380255751"] = true,
    ["rbxassetid://13362587853"] = true,
    ["rbxassetid://11365563255"] = {range = 175, behind = 17},
    ["rbxassetid://12983333733"] = {range = 200, behind = 16},
    ["rbxassetid://13927612951"] = {range = 100, behind = 16},
    ["rbxassetid://13146710762"] = {range = 200, behind = 24},
    ["rbxassetid://15520132233"] = {range = 100, behind = 75},
    ["rbxassetid://16082123712"] = {range = 40, behind = 20}
}

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local detectionRange = 15
local detectionMode = "360" -- Default to 360 detection
local lastTeleportTime = 0

local function getNearbyPlayers(radius)
    local players = {}
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player then
            local otherCharacter = otherPlayer.Character
            if otherCharacter then
                local otherHumanoidRootPart = otherCharacter:FindFirstChild("HumanoidRootPart")
                if otherHumanoidRootPart and (otherHumanoidRootPart.Position - humanoidRootPart.Position).Magnitude <= radius then
                    table.insert(players, otherPlayer)
                end
            end
        end
    end
    return players
end

local function isInFront(character, target)
    local lookVector = character.CFrame.lookVector
    local directionToTarget = (target.Position - character.Position).unit
    return lookVector:Dot(directionToTarget) > 0.5 -- Adjust the threshold as necessary
end

local function checkAnimations()
    local currentTime = tick()
    if currentTime - lastTeleportTime < 0.1 then
        return
    end
    
    local nearbyPlayers = getNearbyPlayers(detectionRange)
    for _, otherPlayer in pairs(nearbyPlayers) do
        local otherCharacter = otherPlayer.Character
        if otherCharacter then
            local otherHumanoidRootPart = otherCharacter:FindFirstChild("HumanoidRootPart")
            if otherHumanoidRootPart then
                if (detectionMode == "360" or isInFront(humanoidRootPart, otherHumanoidRootPart)) then
                    for _, animTrack in pairs(otherCharacter:FindFirstChildOfClass("Humanoid"):GetPlayingAnimationTracks()) do
                        local animId = animTrack.Animation.AnimationId
                        local data = animationIDs[animId]
                        if data then
                            local teleportDistance = (type(data) == "table" and data.behind) or 18 -- default behind distance
                            local newPosition = otherHumanoidRootPart.Position - otherHumanoidRootPart.CFrame.lookVector * teleportDistance + Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
                            humanoidRootPart.CFrame = CFrame.new(newPosition)
                            lastTeleportTime = currentTime
                            return
                        end
                    end
                end
            end
        end
    end
end

local ultraInstinctActive = false

local RunService = game:GetService("RunService")

local function ultraInstinctLoop()
    local connection
    connection = RunService.Heartbeat:Connect(function()
        if ultraInstinctActive then
            checkAnimations()
        else
            connection:Disconnect()
        end
    end)
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    if ultraInstinctActive then
        ultraInstinctLoop()
    end
end

player.CharacterAdded:Connect(onCharacterAdded)

tab.newToggle("Ultra Instinct", "Makes you almost unhitable", true, function(toggleState)
    ultraInstinctActive = toggleState
    if ultraInstinctActive then
        print("Ultra Instinct On")
        ultraInstinctLoop()
    else
        print("Ultra Instinct Off")
    end
end)

tab.newSlider("Ultra Instinct Range Slider", "changes the range of the Ultra Instinct", 75, false, function(num)
    detectionRange = num
    print("Detection Range: " .. num)
end)

tab.newDropdown("Ultra Instinct Detection Type", "Choose the detection type", {"Front Facing", "360"}, function(selectedOption)
    detectionMode = selectedOption
    print("Detection Mode: " .. selectedOption)
end)

local animationsToAvoid = {
    ["rbxassetid://10468665991"] = true,
    ["rbxassetid://10466974800"] = true,
    ["rbxassetid://10471336737"] = true,
    ["rbxassetid://12510170988"] = true,
    ["rbxassetid://12272894215"] = true,
    ["rbxassetid://12296882427"] = true,
    ["rbxassetid://12307656616"] = true,
    ["rbxassetid://12351854556"] = true,
    ["rbxassetid://12534735382"] = true,
    ["rbxassetid://12502664044"] = true,
    ["rbxassetid://12509505723"] = true,
    ["rbxassetid://12618292188"] = true,
    ["rbxassetid://12684185971"] = true,
    ["rbxassetid://13376869471"] = true,
    ["rbxassetid://13294790250"] = true,
    ["rbxassetid://13376962659"] = true,
    ["rbxassetid://13501296372"] = true,
    ["rbxassetid://14004235777"] = true,
    ["rbxassetid://14003607057"] = true,
    ["rbxassetid://14046756619"] = true,
    ["rbxassetid://14048349132"] = true,
    ["rbxassetid://14299135500"] = true,
    ["rbxassetid://14967219354"] = true,
    ["rbxassetid://14357997687"] = true,
    ["rbxassetid://14357943487"] = true,
    ["rbxassetid://15290930205"] = true,
    ["rbxassetid://15145462680"] = true,
    ["rbxassetid://15295895753"] = true,
    ["rbxassetid://15311685628"] = true,
    ["rbxassetid://16139108718"] = true,
    ["rbxassetid://16139402582"] = true,
    ["rbxassetid://16515850153"] = true,
    ["rbxassetid://16431491215"] = true,
    ["rbxassetid://16597322398"] = true,
    ["rbxassetid://10469493270"] = "special"
}

local skills = {
    firstskill = {"Normal Punch", "Flowing Water", "Machine Gun Blows", "Flash Strike", "Homerun", "Quick Slice", "Bullet Barrage", "Crushing Pull"},
    secondskill = {"Atmos Cleave", "Windstorm Fury", "Ignition Burst", "Whirlwind Kick", "Beatdown", "Consecutive Punches", "Lethal Whirlwind Stream", "Vanishing Kick"},
    thirdskill = {"Shove", "Hunter's Grasp", "Blitz Shot", "Scatter", "Grand Slam", "Pinpoint Cut", "Stone Coffin", "Whirlwind Drop"},
    fourthskill = {"Split Second Counter", "Expulsive Push", "Jet Dive", "Explosive Shuriken", "Foul Ball", "Uppercut", "Head First", "Prey's Peril"}
}

local skillCooldowns = {
    ["Normal Punch"] = 21,
    ["Flowing Water"] = 19,
    ["Machine Gun Blows"] = 17,
    ["Flash Strike"] = 18.5,
    ["Homerun"] = 18.6,
    ["Quick Slice"] = 21.5,
    ["Bullet Barrage"] = 22,
    ["Crushing Pull"] = 23,
    ["Consecutive Punches"] = 19,
    ["Lethal Whirlwind Stream"] = 22,
    ["Ignition Burst"] = 18.3,
    ["Whirlwind Kick"] = 21.5,
    ["Beatdown"] = 24.3,
    ["Atmos Cleave"] = 23.2,
    ["Windstorm Fury"] = 21,
    ["Vanishing Kick"] = 21,
    ["Shove"] = 11,
    ["Hunter's Grasp"] = 17.8,
    ["Blitz Shot"] = 26,
    ["Scatter"] = 22.3,
    ["Grand Slam"] = 21.7,
    ["Pinpoint Cut"] = 18,
    ["Stone Coffin"] = 25.7,
    ["Whirlwind Drop"] = 15.7,
    ["Jet Dive"] = 19.5,
    ["Explosive Shuriken"] = 18.5,
    ["Foul Ball"] = 24.8,
    ["Split Second Counter"] = 18.7,
    ["Expulsive Push"] = 20.7,
    ["Prey's Peril"] = 18.5,
    ["Head First"] = 22,
    ["Uppercut"] = 21
}

local skillUsage = {
    firstskill = 0,
    secondskill = 0,
    thirdskill = 0,
    fourthskill = 0
}

local function isAnimationPlaying(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
            if animationsToAvoid[track.Animation.AnimationId] then
                return animationsToAvoid[track.Animation.AnimationId]
            end
        end
    end
    return false
end

local function teleportBehindTarget(player, targetPlayer, distance)
    local targetCharacter = targetPlayer.Character
    if targetCharacter then
        local targetHRP = targetCharacter:FindFirstChild("HumanoidRootPart")
        local playerHRP = player.Character:FindFirstChild("HumanoidRootPart")
        if targetHRP and playerHRP then
            local backOffset = targetHRP.CFrame.lookVector * -distance
            playerHRP.CFrame = CFrame.new(targetHRP.Position + backOffset, targetHRP.Position)
        end
    end
end

local function equipAndUseSkill(player, skillType)
    local character = player.Character
    if character then
        local backpack = player.Backpack
        local liveFolder = workspace:FindFirstChild("Live")
        if backpack and liveFolder then
            for _, skill in pairs(skills[skillType]) do
                local tool = backpack:FindFirstChild(skill) or character:FindFirstChild(skill)
                if tool then
                    character.Humanoid:EquipTool(tool)
                    
                    -- Execute left click and left click release actions
                    local args = {
                        [1] = {
                            ["Mobile"] = true,
                            ["Goal"] = "LeftClick"
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    wait(0.02)

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))

                    -- Unequip tool
                    character.Humanoid:UnequipTools()

                    -- Wait for cooldown if defined
                    if skillCooldowns[skill] then
                        skillUsage[skillType] = tick()
                        wait(skillCooldowns[skill])
                    end
                end
            end
        end
    end
end

local autoFarmThread
local useFirstSkill = false
local useSecondSkill = false
local useThirdSkill = false
local useFourthSkill = false
local ignoreFriends = false
local specificPlayerUsername = ""
local specificPlayerTarget = nil

local function findClosestMatchingPlayer(inputName)
    local players = game:GetService("Players"):GetPlayers()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, player in pairs(players) do
        local distance = string.len(player.Name) + string.len(inputName) - 2 * string.len(player.Name:sub(1, string.len(inputName)))
        if distance < closestDistance then
            closestDistance = distance
            closestPlayer = player
        end
    end

    return closestPlayer
end

local function autoFarm()
    local player = game:GetService("Players").LocalPlayer
    local targetPlayer

    while true do
        wait(0.02)

        -- Select target player
        if specificPlayerTarget then
            targetPlayer = specificPlayerTarget
        else
            if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
                local players = game:GetService("Players"):GetPlayers()
                repeat
                    targetPlayer = players[math.random(1, #players)]
                until targetPlayer ~= player and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and (not ignoreFriends or not player:IsFriendsWith(targetPlayer.UserId))
            end
        end

        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            repeat wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        end

        local function handleAvoidAnimation()
            local endTime = tick() + 1
            while tick() < endTime do
                teleportBehindTarget(player, targetPlayer, 13)
                wait(0.02)
            end
        end

        if isAnimationPlaying(targetPlayer.Character) then
            handleAvoidAnimation()
        else
            teleportBehindTarget(player, targetPlayer, 3)

            local args = {
                [1] = {
                    ["Goal"] = "LeftClick",
                    ["Mobile"] = true
                }
            }
            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

            local argsRelease = {
                [1] = {
                    ["Goal"] = "LeftClickRelease",
                    ["Mobile"] = true
                }
            }
            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))

            local currentTime = tick()

            -- Use skills concurrently without stopping the teleportation
            if useFirstSkill and (currentTime - skillUsage["firstskill"] >= skillCooldowns[skills.firstskill[1]]) then
                coroutine.wrap(equipAndUseSkill)(player, "firstskill")
                skillUsage["firstskill"] = currentTime
            end
            if useSecondSkill and (currentTime - skillUsage["secondskill"] >= skillCooldowns[skills.secondskill[1]]) then
                coroutine.wrap(equipAndUseSkill)(player, "secondskill")
                skillUsage["secondskill"] = currentTime
            end
            if useThirdSkill and (currentTime - skillUsage["thirdskill"] >= skillCooldowns[skills.thirdskill[1]]) then
                coroutine.wrap(equipAndUseSkill)(player, "thirdskill")
                skillUsage["thirdskill"] = currentTime
            end
            if useFourthSkill and (currentTime - skillUsage["fourthskill"] >= skillCooldowns[skills.fourthskill[1]]) then
                coroutine.wrap(equipAndUseSkill)(player, "fourthskill")
                skillUsage["fourthskill"] = currentTime
            end
        end
    end
end

tab.newToggle("Auto Farm", "Auto Farms kills for you", true, function(toggleState)
    if toggleState then
        autoFarmThread = coroutine.create(autoFarm)
        coroutine.resume(autoFarmThread)
    else
        if autoFarmThread then
            coroutine.close(autoFarmThread)
            autoFarmThread = nil
        end
    end
end)

tab.newToggle("Uses first skill", "Uses your first skill with the Auto Farm", true, function(toggleState)
    useFirstSkill = toggleState
end)

tab.newToggle("Use second skill", "Uses your second skill while auto farming", true, function(toggleState)
    useSecondSkill = toggleState
end)

tab.newToggle("Use third skill", "Uses your third skill while auto farming", true, function(toggleState)
    useThirdSkill = toggleState
end)

tab.newToggle("Use fourth skill", "Uses your fourth skill while auto farming", true, function(toggleState)
    useFourthSkill = toggleState
end)

tab.newInput("Auto Farm Specific Player", "Auto Farms A Specific User. Put their username or a short form of their username", function(text)
    specificPlayerUsername = text
    specificPlayerTarget = findClosestMatchingPlayer(specificPlayerUsername)
end)

tab.newButton("Stop Farming Specific Player", "Stops auto farming the specific player", function()
    specificPlayerTarget = nil
end)

tab.newToggle("Auto Farm Ignore Friends", "The Auto Farm Will Ignore your Roblox friends only ignores roblox freinds bc u dont have irl ones", true, function(toggleState)
    ignoreFriends = toggleState
end)


print("Rinns Hub On Top.")
local autoBlockEnabled = false
local detectionMode = "360"  -- Default detection mode
local autoBlockRange = 50
local autoPunchEnabled = false

tab.newToggle("Auto Block", "Auto Blocks Blockable skills for you", true, function(toggleState)
    autoBlockEnabled = toggleState
    if toggleState then
        print("Auto Block On")
    else
        print("Auto Block Off")
    end
end)

tab.newSlider("Auto Block Range Slider", "Changes the Range of the auto block", 50, false, function(num)
    autoBlockRange = num
    print(num)
end)

tab.newDropdown("Detection Mode", "Select one of these options!", {"360", "Front Facing"}, function(selectedOption)
    detectionMode = selectedOption
    print("Detection Mode set to:", selectedOption)
end)

tab.newToggle("Auto Punch/Auto M1", "Auto Punches For You works with the auto block but you can't change the settings", true, function(toggleState)
    autoPunchEnabled = toggleState
    if toggleState then
        print("Auto Punch On")
    else
        print("Auto Punch Off")
    end
end)

-- Define the punch animations to detect
local punchAnimations = {
    ["10469493270"] = true,
    ["10469630950"] = true,
    ["10469639222"] = true,
    ["10469643643"] = true,
    ["13532562418"] = true,
    ["13491635433"] = true,
    ["13296577783"] = true,
    ["13295919399"] = true,
    ["13370310513"] = true,
    ["13390230973"] = true,
    ["13378751717"] = true,
    ["13378708199"] = true,
    ["14004222985"] = true,
    ["13997092940"] = true,
    ["14001963401"] = true,
    ["14136436157"] = true,
    ["15259161390"] = true,
    ["15240216931"] = true,
    ["15240176873"] = true,
    ["15162694192"] = true,
    ["16515503507"] = true,
    ["16515520431"] = true,
    ["16515448089"] = true,
    ["16552234590"] = true,
    ["17889458563"] = true,
    ["17889461810"] = true,
    ["17889471098"] = true,
    ["17889290569"] = true
}

-- Define the dash animations to detect
local dashAnimations = {
    ["10479335397"] = true,
    ["13380255751"] = true
}

-- Define the skill animations to detect with their respective delays
local skillAnimations = {
    ["10466974800"] = 1.8,  -- Satima Punches
    ["12534735382"] = 1.9,
    ["14046756619"] = 0.5,
    ["13376962659"] = 1.0,  -- Scatter Sonic
    ["12296882427"] = 0.4,
    ["12618292188"] = 0.6,
    ["12618271998"] = 0.6,
    ["13376869471"] = 0.5,
    ["17799224866"] = 0.9,  -- Bullet Barrage
    ["18179181663"] = 0.6,  -- Headfirst
    ["16515850153"] = 0.8,  -- Windstorm Fury
    ["16431491215"] = 0.7   -- Stone Coffin
}

-- Define the block animation to detect
local blockAnimations = {
    ["BlockingAnimationId"] = true -- Replace with the actual animation ID for blocking
}

-- Function to check if a player is within range
local function isPlayerInRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            return distance <= range
        end
    end
    return false
end

-- Function to check if a player is within the front-facing range
local function isPlayerInFrontFacingRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            if distance <= range then
                local direction = (targetRootPart.Position - rootPart.Position).Unit
                local lookVector = rootPart.CFrame.LookVector
                local angle = math.acos(direction:Dot(lookVector))
                return angle <= math.rad(90)  -- 90 degrees for front-facing detection
            end
        end
    end
    return false
end

-- Function to check if the local player is playing any of the specified animations
local function isLocalPlayerPlayingAnimation()
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
        local animId = animTrack.Animation.AnimationId:match("%d+$")
        if punchAnimations[animId] or dashAnimations[animId] or skillAnimations[animId] then
            return true
        end
    end
    return false
end

-- Function to check if the local player is blocking
local function isLocalPlayerBlocking()
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
        local animId = animTrack.Animation.AnimationId:match("%d+$")
        if blockAnimations[animId] then
            return true
        end
    end
    return false
end

-- Function to detect animations
local function detectAnimations()
    local players = game:GetService("Players")

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer then
            local inRange = false
            if detectionMode == "360" then
                inRange = isPlayerInRange(player, autoBlockRange)
            elseif detectionMode == "Front Facing" then
                inRange = isPlayerInFrontFacingRange(player, autoBlockRange)
            end

            if inRange then
                local character = player.Character
                if character then
                    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
                        local animId = animTrack.Animation.AnimationId:match("%d+$")
                        if not isLocalPlayerPlayingAnimation() then
                            if punchAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.45)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif dashAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.90)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif skillAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(skillAnimations[animId])

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Function to perform auto punch
local function autoPunch()
    local players = game:GetService("Players")

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer then
            local inRange = false
            if detectionMode == "360" then
                inRange = isPlayerInRange(player, 7)
            elseif detectionMode == "Front Facing" then
                inRange = isPlayerInFrontFacingRange(player, 7)
            end

            if inRange and not isLocalPlayerBlocking() then
                local args = {
                    [1] = {
                        ["Goal"] = "LeftClick",
                        ["Mobile"] = true
                    }
                }
                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                local argsRelease = {
                    [1] = {
                        ["Goal"] = "LeftClickRelease",
                        ["Mobile"] = true
                    }
                }
                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
            end
        end
    end
end

-- Connect the detection functions to RunService
game:GetService("RunService").Heartbeat:Connect(function()
    if autoBlockEnabled then
        detectAnimations()
    end
    if autoPunchEnabled then
        autoPunch()
    end
end)

local aimbotEnabled = false
local aimbotCircleSize = 100
local aimbotCircle = nil
local teleportToSafePlaceEnabled = false
local originalPosition = nil

-- Create a really big part at the specified position
local bigPart = Instance.new("Part")
bigPart.Size = Vector3.new(100, 1, 100)
bigPart.Position = Vector3.new(-10487.8212890625, 16371.6865234375, -19404.552734375)
bigPart.Anchored = true
bigPart.Parent = game.Workspace

-- New Text Input for Combo Maker
tab.newInput("Auto Combo", "Does the combo you put in it for you (punch();wait(x amount of time you want it to wait);firstskill();secondskill();thirdskill();fourthskill();dash();downslam();moveforward();movebackward())", function(text)
    if text == "" then
        return
    end

    print("Entered text: " .. text)

    -- Create a new tool when input is finished
    local localPlayer = game.Players.LocalPlayer
    local tool = Instance.new("Tool")
    tool.Name = "Combo Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false

    -- Function to execute commands
    local function executeCommands()
        spawn(function()
            local toolNames = {
                ["firstskill()"] = {"Normal Punch", "Flowing Water", "Machine Gun Blows", "Flash Stirke", "Homerun", "Quick Slice", "Crushing Pull"},
                ["secondskill()"] = {"Atmos Cleave", "Windstorm Fury", "Ignition Burst", "Whirlwind Kick", "Beatdown", "Consecutive Punches", "Lethal Whirlwind Stream"},
                ["thirdskill()"] = {"Pinpoint Cut", "Stone Coffin", "Blitz Shot", "Scatter", "Grand Slam", "Shove", "Hunter's Grasp"},
                ["fourthskill()"] = {"Split Second Counter", "Expulsive Push", "Jet Dive", "Explosive Shuriken", "Foul Ball", "Uppercut", "Prey's Peril"}
            }

            for command in string.gmatch(text, "%S+") do
                if toolNames[command] then
                    for _, toolName in ipairs(toolNames[command]) do
                        local tool = localPlayer.Backpack:FindFirstChild(toolName) or localPlayer.Character:FindFirstChild(toolName)
                        if tool then
                            tool.Parent = localPlayer.Character
                            local args = {
                                [1] = {
                                    ["Goal"] = "LeftClick",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                            local argsRelease = {
                                [1] = {
                                    ["Goal"] = "LeftClickRelease",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                            tool.Parent = localPlayer.Backpack
                            break
                        end
                    end
                elseif command:match("^wait%((%d+%.?%d*)%)$") then
                    local waitTime = tonumber(command:match("%d+%.?%d*"))
                    wait(waitTime)
                elseif command == "punch()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.35)
                elseif command == "dash()" then
                    local args = {
                        [1] = {
                            ["Dash"] = Enum.KeyCode.W,
                            ["Key"] = Enum.KeyCode.Q,
                            ["Goal"] = "KeyPress"
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    function getNil(name, class) 
                        for _, v in pairs(getnilinstances()) do 
                            if v.ClassName == class and v.Name == name then 
                                return v
                            end 
                        end 
                    end

                    local args = {
                        [1] = {
                            ["Goal"] = "delete bv",
                            ["BV"] = getNil("moveme", "BodyVelocity")
                        }
                    }

                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    wait(0.85)
                elseif command == "downslam()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.33)

                    game.Players.LocalPlayer.Character.Humanoid.Jump = true
                    wait(0.15)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.1)

                elseif command == "moveforward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5)
                    end
                elseif command == "movebackward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
                    end
                end
            end
        end)
    end

    tool.Activated:Connect(executeCommands)

    tool.Parent = localPlayer.Backpack
end)


-- Toggle for Aimbot
tab.newToggle("Aimbot", "Enables Aimbot to target the nearest player", false, function(toggleState)
    aimbotEnabled = toggleState
    if aimbotEnabled then
        local camera = game.Workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer

        local circle = Drawing.new("Circle")
        circle.Thickness = 2
        circle.Transparency = 0.4
        circle.Color = Color3.fromRGB(255, 255, 255)
        circle.NumSides = 100
        circle.Filled = false

        game:GetService("RunService").RenderStepped:Connect(function()
            if aimbotEnabled then
                circle.Visible = true
                circle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                circle.Radius = aimbotCircleSize

                local closestPlayer = nil
                local shortestDistance = aimbotCircleSize

                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local screenPoint, onScreen = camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - circle.Position).magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end

                if closestPlayer then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, closestPlayer.Character.HumanoidRootPart.Position)
                end
            else
                circle.Visible = false
            end
        end)
    end
end)

-- Slider for Aimbot Circle Size
tab.newSlider("Aimbot Circle Size", "Change the size of the Aimbot circle", 450,
false, function(value)
    aimbotCircleSize = value
end)

-- Toggle for Teleport to Safe Place
tab.newToggle("Teleport to Safe Place When low", "Teleports you to a safe place when your low", false, function(toggleState)
    teleportToSafePlaceEnabled = toggleState
    local player = game.Players.LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

    local function checkHealth()
        if teleportToSafePlaceEnabled and humanoid and humanoid.Health <= 15 then
            if not originalPosition then
                originalPosition = player.Character.PrimaryPart.Position
            end
            local safePlace = Vector3.new(-10492.9931640625, 16379.8828125, -19407.078125)
            player.Character:SetPrimaryPartCFrame(CFrame.new(safePlace))
        elseif originalPosition and humanoid and humanoid.Health >= 30 then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end

    local healthCheckConnection

    if teleportToSafePlaceEnabled then
        healthCheckConnection = game:GetService("RunService").RenderStepped:Connect(checkHealth)
        checkHealth()
    else
        if healthCheckConnection then
            healthCheckConnection:Disconnect()
            healthCheckConnection = nil
        end
        if originalPosition then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end
end)

-- No Stun Button
tab.newButton("No Stun", "Disables or reduces stun effects only click once", function()
    local function isNumber(str)
        return tonumber(str) ~= nil or str == 'inf'
    end

    local tspeed = 0.3
    local hb = game:GetService("RunService").Heartbeat
    local tpwalking = true
    local player = game:GetService("Players")
    local lplr = player.LocalPlayer
    local chr = lplr.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
        if hum.MoveDirection.Magnitude > 0 then
            if tspeed and isNumber(tspeed) then
                chr:TranslateBy(hum.MoveDirection * tonumber(tspeed))
            else
                chr:TranslateBy(hum.MoveDirection)
            end
        end
    end
end)

-- settings
local settings = {
    defaultcolor = Color3.fromRGB(0, 0, 139),  -- Dark Blue
    teamcheck = false,
    teamcolor = true,
    boxESPEnabled = false,
    tracersEnabled = false,
    distanceESPEnabled = false,
    nameESPEnabled = false,
    boxWidth = 4,  -- Width of the box ESP
    boxHeight = 6  -- Height of the box ESP
};

-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");

-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local round = function(...) local a = {}; for i, v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera:WorldToViewportPoint(...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};

local function createEsp(player)
    local drawings = {};

    -- Box ESP
    drawings.boxTop = newDrawing("Line");
    drawings.boxBottom = newDrawing("Line");
    drawings.boxLeft = newDrawing("Line");
    drawings.boxRight = newDrawing("Line");
    
    for _, boxPart in ipairs({drawings.boxTop, drawings.boxBottom, drawings.boxLeft, drawings.boxRight}) do
        boxPart.Thickness = 1;
        boxPart.Color = settings.defaultcolor;
        boxPart.Visible = false;
        boxPart.ZIndex = 2;
    end

    drawings.tracer = newDrawing("Line");
    drawings.tracer.Thickness = 1;
    drawings.tracer.Color = settings.defaultcolor;
    drawings.tracer.Visible = false;
    drawings.tracer.ZIndex = 1;

    drawings.name = newDrawing("Text");
    drawings.name.Text = player.Name;
    drawings.name.Size = 14;
    drawings.name.Center = true;
    drawings.name.Outline = true;
    drawings.name.Visible = false;
    drawings.name.Color = settings.defaultcolor;

    drawings.distance = newDrawing("Text");
    drawings.distance.Size = 14;
    drawings.distance.Center = true;
    drawings.distance.Outline = true;
    drawings.distance.Visible = false;
    drawings.distance.Color = settings.defaultcolor;

    espCache[player] = drawings;
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove();
        end
        espCache[player] = nil;
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character;
    if character then
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart");
        if humanoidRootPart then
            local rootPos, rootVisible = wtvp(humanoidRootPart.Position);
            local visible = rootVisible;

            local color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;
            for _, boxPart in ipairs({esp.boxTop, esp.boxBottom, esp.boxLeft, esp.boxRight}) do
                boxPart.Color = color;
            end
            esp.tracer.Color = color;
            esp.name.Color = color;
            esp.distance.Color = color;

            for _, boxPart in ipairs({esp.boxTop, esp.boxBottom, esp.boxLeft, esp.boxRight}) do
                boxPart.Visible = visible and settings.boxESPEnabled;
            end
            esp.tracer.Visible = settings.tracersEnabled and visible;
            esp.name.Visible = settings.nameESPEnabled and visible;
            esp.distance.Visible = settings.distanceESPEnabled and visible;

            if visible then
                local boxWidth = settings.boxWidth * 10;
                local boxHeight = settings.boxHeight * 10;
                local x, y = round(rootPos.X, rootPos.Y);

                -- Box ESP
                esp.boxTop.From = newVector2(x - boxWidth / 2, y - boxHeight / 2);
                esp.boxTop.To = newVector2(x + boxWidth / 2, y - boxHeight / 2);

                esp.boxBottom.From = newVector2(x - boxWidth / 2, y + boxHeight / 2);
                esp.boxBottom.To = newVector2(x + boxWidth / 2, y + boxHeight / 2);

                esp.boxLeft.From = newVector2(x - boxWidth / 2, y - boxHeight / 2);
                esp.boxLeft.To = newVector2(x - boxWidth / 2, y + boxHeight / 2);

                esp.boxRight.From = newVector2(x + boxWidth / 2, y - boxHeight / 2);
                esp.boxRight.To = newVector2(x + boxWidth / 2, y + boxHeight / 2);

                -- Tracer ESP
                local localHead = localPlayer.Character and localPlayer.Character:FindFirstChild("Head");
                if localHead then
                    local localHeadPos = wtvp(localHead.Position);
                    esp.tracer.From = localHeadPos;
                    esp.tracer.To = rootPos;
                end

                -- Name ESP
                esp.name.Position = newVector2(x, y - boxHeight / 2 - 16);

                -- Distance ESP
                local distance = (localPlayer.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude;
                esp.distance.Text = string.format("%.0f", distance) .. "m";
                esp.distance.Position = newVector2(x, y + boxHeight / 2 + 16);
            end
        end
    else
        for _, boxPart in ipairs({esp.boxTop, esp.boxBottom, esp.boxLeft, esp.boxRight}) do
            boxPart.Visible = false;
        end
        esp.tracer.Visible = false;
        esp.name.Visible = false;
        esp.distance.Visible = false;
    end
end

-- main
for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player);
    end
end

players.PlayerAdded:Connect(function(player)
    createEsp(player);
end);

players.PlayerRemoving:Connect(function(player)
    removeEsp(player);
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then
            continue;
        end

        if drawings and player ~= localPlayer then
            updateEsp(player, drawings);
        end
    end
end)

-- GUI integration
local tab = DrRayLibrary.newTab("Esp Tab", "ImageIdHere")


local staffIds = {
    [1446694201] = true,
    [994994173] = true,
    [1041867508] = true,
    [1001242712] = true,
    [77525605] = true,
    [1059541187] = true,
    [3162123826] = true,
    [31070091] = true
}

local function notifyStaffJoin(staffName)
    local gui = Instance.new("ScreenGui", game.Players.LocalPlayer:WaitForChild("PlayerGui"))
    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 200, 0, 150)
    frame.Position = UDim2.new(0, 10, 1, -160)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.ClipsDescendants = true

    local uiCorner = Instance.new("UICorner", frame)

    local titleLabel = Instance.new("TextLabel", frame)
    titleLabel.Size = UDim2.new(1, 0, 0.2, 0)
    titleLabel.Text = "A Mod/Dev is in your game"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.BackgroundTransparency = 1

    local descriptionLabel = Instance.new("TextLabel", frame)
    descriptionLabel.Size = UDim2.new(1, 0, 0.4, 0)
    descriptionLabel.Position = UDim2.new(0, 0, 0.2, 0)
    descriptionLabel.Text = staffName .. " is in your game"
    descriptionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    descriptionLabel.BackgroundTransparency = 1

    local button = Instance.new("TextButton", frame)
    button.Size = UDim2.new(1, 0, 0.2, 0)
    button.Position = UDim2.new(0, 0, 0.6, 0)
    button.Text = "Would you like to Server Hop?"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.BackgroundColor3 = Color3.fromRGB(50, 50, 50)

    local closeButton = Instance.new("TextButton", frame)
    closeButton.Size = UDim2.new(1, 0, 0.2, 0)
    closeButton.Position = UDim2.new(0, 0, 0.8, 0)
    closeButton.Text = "Close"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)

    local progressBar = Instance.new("Frame", frame)
    progressBar.Size = UDim2.new(1, 0, 0.05, 0)
    progressBar.Position = UDim2.new(0, 0, 0.75, 0)
    progressBar.BackgroundColor3 = Color3.fromRGB(255, 0, 0)

    button.MouseButton1Click:Connect(function()
        game:GetService("TeleportService"):Teleport(game.PlaceId)
    end)

    closeButton.MouseButton1Click:Connect(function()
        gui:Destroy()
    end)

    spawn(function()
        for i = 1, 100 do
            progressBar.Size = UDim2.new(1 - i / 100, 0, 0.05, 0)
            wait(0.08)
        end
        gui:Destroy()
    end)
end

local function checkForStaff()
    for _, player in pairs(game.Players:GetPlayers()) do
        if staffIds[player.UserId] then
            notifyStaffJoin(player.Name)
        end
    end
end

local ultimateTools = {
    "Table Flip", "Serious Punch", "The Final Hunt", "Rock Splitting Fist", "Thunder Kick",
    "Speedblitz Dropkick", "Flamewave Cannon", "Fourfold Flashstrike", "Carnage", "Straight On",
    "Brutal Beatdown", "Strength Difference", "Death Blow", "Solar Cleave", "Sunrise", "Atomic Slash",
    "Sunset", "Psychic Ricochet", "Cosmic Strike", "Terrible Tornado"
}

local function checkUltimateTools()
    for _, player in pairs(game.Players:GetPlayers()) do
        local character = game.Workspace.Live:FindFirstChild(player.Name)
        if character then
            local hasUltimateTool = false
            for _, toolName in pairs(ultimateTools) do
                if player.Backpack:FindFirstChild(toolName) or character:FindFirstChild(toolName) then
                    hasUltimateTool = true
                    break
                end
            end

            if hasUltimateTool then
                if not character:FindFirstChild("UltimateWarning") then
                    local warning = Instance.new("BillboardGui", character)
                    warning.Name = "UltimateWarning"
                    warning.Size = UDim2.new(0, 50, 0, 50)
                    warning.StudsOffset = Vector3.new(0, 2, 0)
                    warning.Adornee = character:FindFirstChild("Head")
                    local label = Instance.new("TextLabel", warning)
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Text = ""
                    label.TextColor3 = Color3.fromRGB(255, 0, 0)
                    label.TextScaled = true
                end
            else
                if character:FindFirstChild("UltimateWarning") then
                    character.UltimateWarning:Destroy()
                end
            end
        end
    end
end

local function checkDeathCounter()
    for _, player in pairs(game.Players:GetPlayers()) do
        local character = game.Workspace.Live:FindFirstChild(player.Name)
        if character then
            local hasDeathCounter = character:FindFirstChild("Counter") ~= nil
            if hasDeathCounter then
                if not character:FindFirstChild("DeathCounterWarning") then
                    local warning = Instance.new("BillboardGui", character)
                    warning.Name = "DeathCounterWarning"
                    warning.Size = UDim2.new(0, 50, 0, 50)
                    warning.StudsOffset = Vector3.new(0, 2, 0)
                    warning.Adornee = character:FindFirstChild("Head")
                    local label = Instance.new("TextLabel", warning)
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.BackgroundTransparency = 1
                    label.Text = ""
                    label.TextColor3 = Color3.fromRGB(255, 0, 0)
                    label.TextScaled = true
                end
            else
                if character:FindFirstChild("DeathCounterWarning") then
                    character.DeathCounterWarning:Destroy()
                end
            end
        end
    end
end

tab.newToggle("Notify When Staff Joins", "Sends A Notification When A Staff Member Joins Your Server", true, function(toggleState)
    if toggleState then
        game.Players.PlayerAdded:Connect(function(player)
            if staffIds[player.UserId] then
                notifyStaffJoin(player.Name)
            end
        end)
        checkForStaff()
    end
end)

tab.newButton("Test Staff Notify", "Click this to test the Staff Notifying system", function()
    notifyStaffJoin("Test Staff")
end)

tab.newToggle("Ultimate Esp", "Shows A Warning Sign Above Those Who Are In Ultimate", true, function(toggleState)
    if toggleState then
        while toggleState do
            checkUltimateTools()
            wait(1)
        end
    else
        for _, player in pairs(game.Players:GetPlayers()) do
            local character = game.Workspace.Live:FindFirstChild(player.Name)
            if character and character:FindFirstChild("UltimateWarning") then
                character.UltimateWarning:Destroy()
            end
        end
    end
end)

tab.newToggle("Death Counter Esp", "Puts A Skull above those who have Death Counter On", true, function(toggleState)
    if toggleState then
        while toggleState do
            checkDeathCounter()
            wait(1)
        end
    else
        for _, player in pairs(game.Players:GetPlayers()) do
            local character = game.Workspace.Live:FindFirstChild(player.Name)
            if character and character:FindFirstChild("DeathCounterWarning") then
                character.DeathCounterWarning:Destroy()
            end
        end
    end
end)

tab.newToggle("Box Esp", "Draws a box around every player", true, function(toggleState)
    settings.boxESPEnabled = toggleState;
end)

tab.newToggle("Tracers Esp", "Draws a line to every player", true, function(toggleState)
    settings.tracersEnabled = toggleState;
end)

tab.newToggle("Distance Esp", "Displays the distance to every player", true, function(toggleState)
    settings.distanceESPEnabled = toggleState;
end)

tab.newToggle("Name Esp", "Displays the name of every player", true, function(toggleState)
    settings.nameESPEnabled = toggleState;
end)

local tab = DrRayLibrary.newTab("Misc Tab", "ImageIdHere")

tab.newButton("Change To The Strongest Hero", "Changes your character to the strongest hero", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Bald"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Hero Hunter", "Changes your character to Hero Hunter", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Hunter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Destructive Cyborg", "Changes your character to Destructive Cyborg", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Cyborg"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Deadly Ninja", "Changes your character to Deadly Ninja", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Ninja"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Brutal Demon", "Changes your character to Brutal Demon", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Batter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Blade Master", "Changes your character to Blade Master", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Blade"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Wild Psychic", "Changes your character to Wild Psychic", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Esper"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

-- Button for Rejoin
tab.newButton("Rejoin", "Rejoin the game", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end)

-- Button for Serverhop
tab.newButton("Serverhop", "Hop to another server", function()
    local ts = game:GetService("TeleportService")
    local http = game:GetService("HttpService")
    local servers = {}
    local function listServers(cursor)
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        if cursor then
            url = url .. "&cursor=" .. cursor
        end
        local response = game:HttpGet(url)
        return http:JSONDecode(response)
    end
    local serverData = listServers()
    for _, server in ipairs(serverData.data) do
        if server.playing < server.maxPlayers then
            table.insert(servers, server.id)
        end
    end
    if #servers > 0 then
        ts:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
    else
        warn("No available servers found.")
    end
end)

local autoToxicEnabled = false

tab.newToggle("Auto Toxic", "Says Something when someone dies lmao", true, function(toggleState)
    autoToxicEnabled = toggleState
    print(toggleState and "On" or "Off")
end)

-- Function to handle when a player dies
local function onPlayerDied(player)
    if autoToxicEnabled then
        local displayName = player.DisplayName
        local messages = {
            displayName .. " wouldn't have died if they were using Rinns Hub",
            displayName .. ", how did you die that fast?",
            displayName .. ", how do you get put in a combo that easily bro"
        }
        
        -- Randomly select one of the messages
        local message = messages[math.random(1, #messages)]
        
        local args = {
            [1] = message,
            [2] = "All"
        }

        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(unpack(args))
    end
end

-- Function to connect death detection for a player's character
local function connectDeathDetection(player)
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid", 10)
        if humanoid then
            humanoid.Died:Connect(function()
                onPlayerDied(player)
            end)
        end
    end)
end

-- Monitor new players joining the game
game:GetService("Players").PlayerAdded:Connect(function(player)
    connectDeathDetection(player)
end)

-- Handle existing players when the script is loaded
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    connectDeathDetection(player)
end

