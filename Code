local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "IMPORTANT", Description = "If any of the toggles are already green turn it off then turn it on for the feature to work black = off green = on"},
    {OutlineColor = Color3.fromRGB(80, 80, 80), Time = 8, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

local window = DrRayLibrary:Load("Rinns Hub", "Default")

local tab = DrRayLibrary.newTab("Main Tab", "ImageIdHere")

local aimbotEnabled = false
local aimbotCircleSize = 100
local aimbotCircle = nil
local teleportToSafePlaceEnabled = false
local originalPosition = nil

-- Create a really big part at the specified position
local bigPart = Instance.new("Part")
bigPart.Size = Vector3.new(100, 1, 100)
bigPart.Position = Vector3.new(-10487.8212890625, 16371.6865234375, -19404.552734375)
bigPart.Anchored = true
bigPart.Parent = game.Workspace

-- New Text Input for Combo Maker
tab.newInput("Combo Maker", "Enter your combo commands here (punch();wait(x);firstskill();secondskill();thirdskill();fourthskill();dash();downslam();moveforward();movebackward())", function(text)
    if text == "" then
        return
    end

    print("Entered text: " .. text)

    -- Create a new tool when input is finished
    local localPlayer = game.Players.LocalPlayer
    local tool = Instance.new("Tool")
    tool.Name = "Combo Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false

    -- Function to execute commands
    local function executeCommands()
        spawn(function()
            local toolNames = {
                ["firstskill()"] = {"Normal Punch", "Flowing Water", "Machine Gun Blows", "Flash Stirke", "Homerun", "Quick Slice", "Crushing Pull"},
                ["secondskill()"] = {"Atmos Cleave", "Windstorm Fury", "Ignition Burst", "Whirlwind Kick", "Beatdown", "Consecutive Punches", "Lethal Whirlwind Stream"},
                ["thirdskill()"] = {"Pinpoint Cut", "Stone Coffin", "Blitz Shot", "Scatter", "Grand Slam", "Shove", "Hunter's Grasp"},
                ["fourthskill()"] = {"Split Second Counter", "Expulsive Push", "Jet Dive", "Explosive Shuriken", "Foul Ball", "Uppercut", "Prey's Peril"}
            }

            for command in string.gmatch(text, "%S+") do
                if toolNames[command] then
                    for _, toolName in ipairs(toolNames[command]) do
                        local tool = localPlayer.Backpack:FindFirstChild(toolName) or localPlayer.Character:FindFirstChild(toolName)
                        if tool then
                            tool.Parent = localPlayer.Character
                            local args = {
                                [1] = {
                                    ["Goal"] = "LeftClick",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                            local argsRelease = {
                                [1] = {
                                    ["Goal"] = "LeftClickRelease",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                            tool.Parent = localPlayer.Backpack
                            break
                        end
                    end
                elseif command:match("^wait%((%d+%.?%d*)%)$") then
                    local waitTime = tonumber(command:match("%d+%.?%d*"))
                    wait(waitTime)
                elseif command == "punch()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.35)
                elseif command == "dash()" then
                    local args = {
                        [1] = {
                            ["Dash"] = Enum.KeyCode.W,
                            ["Key"] = Enum.KeyCode.Q,
                            ["Goal"] = "KeyPress"
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    function getNil(name, class) 
                        for _, v in pairs(getnilinstances()) do 
                            if v.ClassName == class and v.Name == name then 
                                return v
                            end 
                        end 
                    end

                    local args = {
                        [1] = {
                            ["Goal"] = "delete bv",
                            ["BV"] = getNil("moveme", "BodyVelocity")
                        }
                    }

                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    wait(0.85)
                elseif command == "downslam()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.33)

                    game.Players.LocalPlayer.Character.Humanoid.Jump = true
                    wait(0.15)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.1)

                elseif command == "moveforward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5)
                    end
                elseif command == "movebackward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
                    end
                end
            end
        end)
    end

    tool.Activated:Connect(executeCommands)

    tool.Parent = localPlayer.Backpack
end)


-- Toggle for Aimbot
tab.newToggle("Aimbot", "Enables Aimbot to target the nearest player", false, function(toggleState)
    aimbotEnabled = toggleState
    if aimbotEnabled then
        local camera = game.Workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer

        local circle = Drawing.new("Circle")
        circle.Thickness = 2
        circle.Transparency = 0.4
        circle.Color = Color3.fromRGB(255, 255, 255)
        circle.NumSides = 100
        circle.Filled = false

        game:GetService("RunService").RenderStepped:Connect(function()
            if aimbotEnabled then
                circle.Visible = true
                circle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                circle.Radius = aimbotCircleSize

                local closestPlayer = nil
                local shortestDistance = aimbotCircleSize

                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local screenPoint, onScreen = camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - circle.Position).magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end

                if closestPlayer then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, closestPlayer.Character.HumanoidRootPart.Position)
                end
            else
                circle.Visible = false
            end
        end)
    end
end)

-- Slider for Aimbot Circle Size
tab.newSlider("Aimbot Circle Size", "Change the size of the Aimbot circle", 450,
false, function(value)
    aimbotCircleSize = value
end)

-- Toggle for Teleport to Safe Place
tab.newToggle("Teleport to Safe Place When low", "Teleports you to a safe place when your low", false, function(toggleState)
    teleportToSafePlaceEnabled = toggleState
    local player = game.Players.LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

    local function checkHealth()
        if teleportToSafePlaceEnabled and humanoid and humanoid.Health <= 15 then
            if not originalPosition then
                originalPosition = player.Character.PrimaryPart.Position
            end
            local safePlace = Vector3.new(-10492.9931640625, 16379.8828125, -19407.078125)
            player.Character:SetPrimaryPartCFrame(CFrame.new(safePlace))
        elseif originalPosition and humanoid and humanoid.Health >= 30 then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end

    local healthCheckConnection

    if teleportToSafePlaceEnabled then
        healthCheckConnection = game:GetService("RunService").RenderStepped:Connect(checkHealth)
        checkHealth()
    else
        if healthCheckConnection then
            healthCheckConnection:Disconnect()
            healthCheckConnection = nil
        end
        if originalPosition then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end
end)

-- No Stun Button
tab.newButton("No Stun", "Disables or reduces stun effects only click once", function()
    local function isNumber(str)
        return tonumber(str) ~= nil or str == 'inf'
    end

    local tspeed = 0.3
    local hb = game:GetService("RunService").Heartbeat
    local tpwalking = true
    local player = game:GetService("Players")
    local lplr = player.LocalPlayer
    local chr = lplr.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
        if hum.MoveDirection.Magnitude > 0 then
            if tspeed and isNumber(tspeed) then
                chr:TranslateBy(hum.MoveDirection * tonumber(tspeed))
            else
                chr:TranslateBy(hum.MoveDirection)
            end
        end
    end
end)

-- settings
local settings = {
    defaultcolor = Color3.fromRGB(255, 0, 0),
    teamcheck = false,
    teamcolor = true,
    boxESPEnabled = false,
    tracersEnabled = false
};

-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");

-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i, v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};

local function createEsp(player)
    local drawings = {};

    drawings.box = newDrawing("Square");
    drawings.box.Thickness = 1;
    drawings.box.Filled = false;
    drawings.box.Color = settings.defaultcolor;
    drawings.box.Visible = false;
    drawings.box.ZIndex = 2;

    drawings.boxoutline = newDrawing("Square");
    drawings.boxoutline.Thickness = 2; -- Making the outline thinner
    drawings.boxoutline.Filled = false;
    drawings.boxoutline.Color = newColor3();
    drawings.boxoutline.Visible = false;
    drawings.boxoutline.ZIndex = 1;

    drawings.tracer = newDrawing("Line");
    drawings.tracer.Thickness = 1;
    drawings.tracer.Color = settings.defaultcolor;
    drawings.tracer.Visible = false;
    drawings.tracer.ZIndex = 1;

    espCache[player] = drawings;
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove();
        end
        espCache[player] = nil;
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character;
    if character then
        local head = character:FindFirstChild("Head");
        local rootPart = character:FindFirstChild("HumanoidRootPart");
        if head and rootPart then
            local headPos, headVisible = wtvp(head.Position);
            local rootPos, rootVisible = wtvp(rootPart.Position);
            local visible = headVisible and rootVisible;
            
            esp.box.Visible = visible and settings.boxESPEnabled;
            esp.boxoutline.Visible = visible and settings.boxESPEnabled;
            esp.tracer.Visible = visible and settings.tracersEnabled;

            if visible then
                local min = character:GetModelCFrame().Position - Vector3.new(2, 3, 0);
                local max = character:GetModelCFrame().Position + Vector3.new(2, 3, 0);
                local minPos, minVisible = wtvp(min);
                local maxPos, maxVisible = wtvp(max);
                if minVisible and maxVisible then
                    local width = math.abs(minPos.X - maxPos.X);
                    local height = math.abs(minPos.Y - maxPos.Y);
                    local x, y = round(minPos.X, minPos.Y);

                    esp.box.Size = newVector2(width, height);
                    esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
                    esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;

                    esp.boxoutline.Size = esp.box.Size;
                    esp.boxoutline.Position = esp.box.Position;

                    local localHead = localPlayer.Character and localPlayer.Character:FindFirstChild("Head");
                    if localHead then
                        local localHeadPos = wtvp(localHead.Position);
                        esp.tracer.From = localHeadPos;
                        esp.tracer.To = headPos;
                        esp.tracer.Color = esp.box.Color;
                    end
                end
            end
        end
    else
        esp.box.Visible = false;
        esp.boxoutline.Visible = false;
        esp.tracer.Visible = false;
    end
end

local function rainbowColorTransition()
    local t = tick() * 0.1
    return Color3.fromHSV(t % 1, 1, 1)
end

-- main
for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player);
    end
end

players.PlayerAdded:Connect(function(player)
    createEsp(player);
end);

players.PlayerRemoving:Connect(function(player)
    removeEsp(player);
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then
            continue;
        end

        if drawings and player ~= localPlayer then
            updateEsp(player, drawings);
            drawings.box.Color = rainbowColorTransition();
            drawings.tracer.Color = drawings.box.Color;
        end
    end
end)

-- GUI integration
local tab = DrRayLibrary.newTab("Esp Tab", "ImageIdHere")

tab.newToggle("Box Esp", "Draws a box around every player", true, function(toggleState)
    settings.boxESPEnabled = toggleState
end)

tab.newToggle("Tracers Esp", "Draws a line to every player", true, function(toggleState)
    settings.tracersEnabled = toggleState
end)

local tab = DrRayLibrary.newTab("Misc Tab", "ImageIdHere")

tab.newButton("Change To The Strongest Hero", "Changes your character to the strongest hero", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Bald"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Hero Hunter", "Changes your character to Hero Hunter", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Hunter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Destructive Cyborg", "Changes your character to Destructive Cyborg", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Cyborg"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Deadly Ninja", "Changes your character to Deadly Ninja", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Ninja"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Brutal Demon", "Changes your character to Brutal Demon", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Batter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Blade Master", "Changes your character to Blade Master", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Blade"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Wild Psychic", "Changes your character to Wild Psychic", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Esper"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

-- Button for Rejoin
tab.newButton("Rejoin", "Rejoin the game", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end)

-- Button for Serverhop
tab.newButton("Serverhop", "Hop to another server", function()
    local ts = game:GetService("TeleportService")
    local http = game:GetService("HttpService")
    local servers = {}
    local function listServers(cursor)
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        if cursor then
            url = url .. "&cursor=" .. cursor
        end
        local response = game:HttpGet(url)
        return http:JSONDecode(response)
    end
    local serverData = listServers()
    for _, server in ipairs(serverData.data) do
        if server.playing < server.maxPlayers then
            table.insert(servers, server.id)
        end
    end
    if #servers > 0 then
        ts:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
    else
        warn("No available servers found.")
    end
end)
