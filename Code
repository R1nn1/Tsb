
local DrRayLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()

local NotificationHolder = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Module.Lua"))()
local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/BocusLuke/UI/main/STX/Client.Lua"))()

Notification:Notify(
    {Title = "IMPORTANT", Description = "If any of the toggles are already green turn it off then turn it on for the feature to work black = off green = on"},
    {OutlineColor = Color3.fromRGB(80, 80, 80), Time = 8, Type = "option"},
    {Image = "http://www.roblox.com/asset/?id=6023426923", ImageColor = Color3.fromRGB(255, 84, 84), Callback = function(State) print(tostring(State)) end}
)

local window = DrRayLibrary:Load("Rinns Hub", "Default")

local tab = DrRayLibrary.newTab("Main Tab", "ImageIdHere")

local autoBlockEnabled = false
local detectionMode = "360"  -- Default detection mode
local autoBlockRange = 50

tab.newToggle("Auto Block", "Auto Blocks Blockable skills for you", true, function(toggleState)
    autoBlockEnabled = toggleState
    if toggleState then
        print("On")
    else
        print("Off")
    end
end)

tab.newSlider("Auto Block Range Slider", "Changes the Range of the auto block", 50, false, function(num)
    autoBlockRange = num
    print(num)
end)

tab.newDropdown("Detection Mode", "Select one of these options!", {"360", "Front Facing"}, function(selectedOption)
    detectionMode = selectedOption
    print("Detection Mode set to:", selectedOption)
end)

-- Define the punch animations to detect
local punchAnimations = {
    ["10469493270"] = true,
    ["10469630950"] = true,
    ["10469639222"] = true,
    ["10469643643"] = true,
    ["13532562418"] = true,
    ["13491635433"] = true,
    ["13296577783"] = true,
    ["13295919399"] = true,
    ["13370310513"] = true,
    ["13390230973"] = true,
    ["13378751717"] = true,
    ["13378708199"] = true,
    ["14004222985"] = true,
    ["13997092940"] = true,
    ["14001963401"] = true,
    ["14136436157"] = true,
    ["15259161390"] = true,
    ["15240216931"] = true,
    ["15240176873"] = true,
    ["15162694192"] = true,
    ["16515503507"] = true,
    ["16515520431"] = true,
    ["16515448089"] = true,
    ["16552234590"] = true,
    ["17889458563"] = true,
    ["17889461810"] = true,
    ["17889471098"] = true,
    ["17889290569"] = true
}

-- Define the dash animations to detect
local dashAnimations = {
    ["10479335397"] = true,
    ["13380255751"] = true
}

-- Define the skill animations to detect with their respective delays
local skillAnimations = {
    ["10466974800"] = 1.8,  -- Satima Punches
    ["12534735382"] = 1.9,
    ["14046756619"] = 0.5,
    ["13376962659"] = 1.0,  -- Scatter Sonic
    ["12296882427"] = 0.4,
    ["12618292188"] = 0.6,
    ["12618271998"] = 0.6,
    ["13376869471"] = 0.5,
    ["17799224866"] = 0.9,  -- Bullet Barrage
    ["18179181663"] = 0.6,  -- Headfirst
    ["16515850153"] = 0.8,  -- Windstorm Fury
    ["16431491215"] = 0.7   -- Stone Coffin
}

-- Function to check if a player is within range
local function isPlayerInRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            return distance <= range
        end
    end
    return false
end

-- Function to check if a player is within the front-facing range
local function isPlayerInFrontFacingRange(player, range)
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local targetCharacter = player.Character
    if targetCharacter then
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
        if targetRootPart then
            local distance = (rootPart.Position - targetRootPart.Position).Magnitude
            if distance <= range then
                local direction = (targetRootPart.Position - rootPart.Position).Unit
                local lookVector = rootPart.CFrame.LookVector
                local angle = math.acos(direction:Dot(lookVector))
                return angle <= math.rad(90)  -- 90 degrees for front-facing detection
            end
        end
    end
    return false
end

-- Function to check if the local player is playing any of the specified animations
local function isLocalPlayerPlayingAnimation()
    local localPlayer = game:GetService("Players").LocalPlayer
    local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
        local animId = animTrack.Animation.AnimationId:match("%d+$")
        if punchAnimations[animId] or dashAnimations[animId] or skillAnimations[animId] then
            return true
        end
    end
    return false
end

-- Function to detect animations
local function detectAnimations()
    local players = game:GetService("Players")

    for _, player in pairs(players:GetPlayers()) do
        if player ~= players.LocalPlayer then
            local inRange = false
            if detectionMode == "360" then
                inRange = isPlayerInRange(player, autoBlockRange)
            elseif detectionMode == "Front Facing" then
                inRange = isPlayerInFrontFacingRange(player, autoBlockRange)
            end

            if inRange then
                local character = player.Character
                if character then
                    for _, animTrack in pairs(character.Humanoid:GetPlayingAnimationTracks()) do
                        local animId = animTrack.Animation.AnimationId:match("%d+$")
                        if not isLocalPlayerPlayingAnimation() then
                            if punchAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.45)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif dashAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(0.90)

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            elseif skillAnimations[animId] then
                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyPress",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                                wait(skillAnimations[animId])

                                local args = {
                                    [1] = {
                                        ["Goal"] = "KeyRelease",
                                        ["Key"] = Enum.KeyCode.F
                                    }
                                }

                                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Connect the detection function to RunService
game:GetService("RunService").Heartbeat:Connect(function()
    if autoBlockEnabled then
        detectAnimations()
    end
end)

local aimbotEnabled = false
local aimbotCircleSize = 100
local aimbotCircle = nil
local teleportToSafePlaceEnabled = false
local originalPosition = nil

-- Create a really big part at the specified position
local bigPart = Instance.new("Part")
bigPart.Size = Vector3.new(100, 1, 100)
bigPart.Position = Vector3.new(-10487.8212890625, 16371.6865234375, -19404.552734375)
bigPart.Anchored = true
bigPart.Parent = game.Workspace

-- New Text Input for Combo Maker
tab.newInput("Combo Maker", "Enter your combo commands here (punch();wait(x);firstskill();secondskill();thirdskill();fourthskill();dash();downslam();moveforward();movebackward())", function(text)
    if text == "" then
        return
    end

    print("Entered text: " .. text)

    -- Create a new tool when input is finished
    local localPlayer = game.Players.LocalPlayer
    local tool = Instance.new("Tool")
    tool.Name = "Combo Tool"
    tool.RequiresHandle = false
    tool.CanBeDropped = false

    -- Function to execute commands
    local function executeCommands()
        spawn(function()
            local toolNames = {
                ["firstskill()"] = {"Normal Punch", "Flowing Water", "Machine Gun Blows", "Flash Stirke", "Homerun", "Quick Slice", "Crushing Pull"},
                ["secondskill()"] = {"Atmos Cleave", "Windstorm Fury", "Ignition Burst", "Whirlwind Kick", "Beatdown", "Consecutive Punches", "Lethal Whirlwind Stream"},
                ["thirdskill()"] = {"Pinpoint Cut", "Stone Coffin", "Blitz Shot", "Scatter", "Grand Slam", "Shove", "Hunter's Grasp"},
                ["fourthskill()"] = {"Split Second Counter", "Expulsive Push", "Jet Dive", "Explosive Shuriken", "Foul Ball", "Uppercut", "Prey's Peril"}
            }

            for command in string.gmatch(text, "%S+") do
                if toolNames[command] then
                    for _, toolName in ipairs(toolNames[command]) do
                        local tool = localPlayer.Backpack:FindFirstChild(toolName) or localPlayer.Character:FindFirstChild(toolName)
                        if tool then
                            tool.Parent = localPlayer.Character
                            local args = {
                                [1] = {
                                    ["Goal"] = "LeftClick",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                            local argsRelease = {
                                [1] = {
                                    ["Goal"] = "LeftClickRelease",
                                    ["Mobile"] = true
                                }
                            }
                            game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                            tool.Parent = localPlayer.Backpack
                            break
                        end
                    end
                elseif command:match("^wait%((%d+%.?%d*)%)$") then
                    local waitTime = tonumber(command:match("%d+%.?%d*"))
                    wait(waitTime)
                elseif command == "punch()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.35)
                elseif command == "dash()" then
                    local args = {
                        [1] = {
                            ["Dash"] = Enum.KeyCode.W,
                            ["Key"] = Enum.KeyCode.Q,
                            ["Goal"] = "KeyPress"
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    function getNil(name, class) 
                        for _, v in pairs(getnilinstances()) do 
                            if v.ClassName == class and v.Name == name then 
                                return v
                            end 
                        end 
                    end

                    local args = {
                        [1] = {
                            ["Goal"] = "delete bv",
                            ["BV"] = getNil("moveme", "BodyVelocity")
                        }
                    }

                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    wait(0.85)
                elseif command == "downslam()" then
                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.36)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.33)

                    game.Players.LocalPlayer.Character.Humanoid.Jump = true
                    wait(0.15)

                    local args = {
                        [1] = {
                            ["Goal"] = "LeftClick",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))

                    local argsRelease = {
                        [1] = {
                            ["Goal"] = "LeftClickRelease",
                            ["Mobile"] = true
                        }
                    }
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(argsRelease))
                    wait(0.1)

                elseif command == "moveforward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, -5)
                    end
                elseif command == "movebackward()" then
                    local localPlayer = game.Players.LocalPlayer
                    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        localPlayer.Character.HumanoidRootPart.CFrame = localPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
                    end
                end
            end
        end)
    end

    tool.Activated:Connect(executeCommands)

    tool.Parent = localPlayer.Backpack
end)


-- Toggle for Aimbot
tab.newToggle("Aimbot", "Enables Aimbot to target the nearest player", false, function(toggleState)
    aimbotEnabled = toggleState
    if aimbotEnabled then
        local camera = game.Workspace.CurrentCamera
        local localPlayer = game.Players.LocalPlayer

        local circle = Drawing.new("Circle")
        circle.Thickness = 2
        circle.Transparency = 0.4
        circle.Color = Color3.fromRGB(255, 255, 255)
        circle.NumSides = 100
        circle.Filled = false

        game:GetService("RunService").RenderStepped:Connect(function()
            if aimbotEnabled then
                circle.Visible = true
                circle.Position = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
                circle.Radius = aimbotCircleSize

                local closestPlayer = nil
                local shortestDistance = aimbotCircleSize

                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local screenPoint, onScreen = camera:WorldToScreenPoint(player.Character.HumanoidRootPart.Position)
                        if onScreen then
                            local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - circle.Position).magnitude
                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end

                if closestPlayer then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, closestPlayer.Character.HumanoidRootPart.Position)
                end
            else
                circle.Visible = false
            end
        end)
    end
end)

-- Slider for Aimbot Circle Size
tab.newSlider("Aimbot Circle Size", "Change the size of the Aimbot circle", 450,
false, function(value)
    aimbotCircleSize = value
end)

-- Toggle for Teleport to Safe Place
tab.newToggle("Teleport to Safe Place When low", "Teleports you to a safe place when your low", false, function(toggleState)
    teleportToSafePlaceEnabled = toggleState
    local player = game.Players.LocalPlayer
    local humanoid = player.Character and player.Character:FindFirstChild("Humanoid")

    local function checkHealth()
        if teleportToSafePlaceEnabled and humanoid and humanoid.Health <= 15 then
            if not originalPosition then
                originalPosition = player.Character.PrimaryPart.Position
            end
            local safePlace = Vector3.new(-10492.9931640625, 16379.8828125, -19407.078125)
            player.Character:SetPrimaryPartCFrame(CFrame.new(safePlace))
        elseif originalPosition and humanoid and humanoid.Health >= 30 then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end

    local healthCheckConnection

    if teleportToSafePlaceEnabled then
        healthCheckConnection = game:GetService("RunService").RenderStepped:Connect(checkHealth)
        checkHealth()
    else
        if healthCheckConnection then
            healthCheckConnection:Disconnect()
            healthCheckConnection = nil
        end
        if originalPosition then
            player.Character:SetPrimaryPartCFrame(CFrame.new(originalPosition))
            originalPosition = nil
        end
    end
end)

-- No Stun Button
tab.newButton("No Stun", "Disables or reduces stun effects only click once", function()
    local function isNumber(str)
        return tonumber(str) ~= nil or str == 'inf'
    end

    local tspeed = 0.3
    local hb = game:GetService("RunService").Heartbeat
    local tpwalking = true
    local player = game:GetService("Players")
    local lplr = player.LocalPlayer
    local chr = lplr.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")

    while tpwalking and hb:Wait() and chr and hum and hum.Parent do
        if hum.MoveDirection.Magnitude > 0 then
            if tspeed and isNumber(tspeed) then
                chr:TranslateBy(hum.MoveDirection * tonumber(tspeed))
            else
                chr:TranslateBy(hum.MoveDirection)
            end
        end
    end
end)

-- settings
local settings = {
    defaultcolor = Color3.fromRGB(0, 0, 139),  -- Dark Blue
    teamcheck = false,
    teamcolor = true,
    boxESPEnabled = false,
    tracersEnabled = false,
    distanceESPEnabled = false,
    nameESPEnabled = false,
    rainbowEnabled = false
};

-- services
local runService = game:GetService("RunService");
local players = game:GetService("Players");

-- variables
local localPlayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;

-- functions
local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new;
local tan, rad = math.tan, math.rad;
local round = function(...) local a = {}; for i, v in next, table.pack(...) do a[i] = math.round(v); end return unpack(a); end;
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end;

local espCache = {};

local function createEsp(player)
    local drawings = {};

    drawings.box = newDrawing("Square");
    drawings.box.Thickness = 1;
    drawings.box.Filled = false;
    drawings.box.Color = settings.defaultcolor;
    drawings.box.Visible = false;
    drawings.box.ZIndex = 2;

    drawings.boxoutline = newDrawing("Square");
    drawings.boxoutline.Thickness = 2; -- Making the outline thinner
    drawings.boxoutline.Filled = false;
    drawings.boxoutline.Color = newColor3();
    drawings.boxoutline.Visible = false;
    drawings.boxoutline.ZIndex = 1;

    drawings.tracer = newDrawing("Line");
    drawings.tracer.Thickness = 1;
    drawings.tracer.Color = settings.defaultcolor;
    drawings.tracer.Visible = false;
    drawings.tracer.ZIndex = 1;

    drawings.name = newDrawing("Text");
    drawings.name.Text = player.Name;
    drawings.name.Size = 14;
    drawings.name.Center = true;
    drawings.name.Outline = true;
    drawings.name.Visible = false;
    drawings.name.Color = settings.defaultcolor;

    drawings.distance = newDrawing("Text");
    drawings.distance.Size = 14;
    drawings.distance.Center = true;
    drawings.distance.Outline = true;
    drawings.distance.Visible = false;
    drawings.distance.Color = settings.defaultcolor;

    espCache[player] = drawings;
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove();
        end
        espCache[player] = nil;
    end
end

local function updateEsp(player, esp)
    local character = player and player.Character;
    if character then
        local head = character:FindFirstChild("Head");
        local rootPart = character:FindFirstChild("HumanoidRootPart");
        if head and rootPart then
            local headPos, headVisible = wtvp(head.Position);
            local rootPos, rootVisible = wtvp(rootPart.Position);
            local visible = headVisible and rootVisible;
            
            esp.box.Visible = visible and settings.boxESPEnabled;
            esp.boxoutline.Visible = visible and settings.boxESPEnabled;
            esp.tracer.Visible = visible and settings.tracersEnabled;
            esp.name.Visible = visible and settings.nameESPEnabled;
            esp.distance.Visible = visible and settings.distanceESPEnabled;

            if visible then
                local minPos, maxPos = Vector3.new(math.huge, math.huge, math.huge), Vector3.new(-math.huge, -math.huge, -math.huge);
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        local partPos = part.Position;
                        if partPos.X < minPos.X then minPos = Vector3.new(partPos.X, minPos.Y, minPos.Z) end
                        if partPos.Y < minPos.Y then minPos = Vector3.new(minPos.X, partPos.Y, minPos.Z) end
                        if partPos.Z < minPos.Z then minPos = Vector3.new(minPos.X, minPos.Y, partPos.Z) end
                        if partPos.X > maxPos.X then maxPos = Vector3.new(partPos.X, maxPos.Y, maxPos.Z) end
                        if partPos.Y > maxPos.Y then maxPos = Vector3.new(maxPos.X, partPos.Y, maxPos.Z) end
                        if partPos.Z > maxPos.Z then maxPos = Vector3.new(maxPos.X, maxPos.Y, partPos.Z) end
                    end
                end
                local minScreenPos, _ = wtvp(minPos);
                local maxScreenPos, _ = wtvp(maxPos);
                local width, height = maxScreenPos.X - minScreenPos.X, maxScreenPos.Y - minScreenPos.Y;
                local x, y = round(minScreenPos.X + width / 2, minScreenPos.Y + height / 2);

                esp.box.Size = newVector2(width, height);
                esp.box.Position = newVector2(round(x - width / 2, y - height / 2));
                esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor;

                esp.boxoutline.Size = esp.box.Size;
                esp.boxoutline.Position = esp.box.Position;

                local localHead = localPlayer.Character and localPlayer.Character:FindFirstChild("Head");
                if localHead then
                    local localHeadPos = wtvp(localHead.Position);
                    esp.tracer.From = localHeadPos;
                    esp.tracer.To = headPos;
                    esp.tracer.Color = esp.box.Color;
                end

                esp.name.Position = newVector2(x, y - height / 2 - 16);
                esp.name.Color = esp.box.Color;

                local distance = (localPlayer.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude;
                esp.distance.Text = string.format("%.0f", distance) .. "m";
                esp.distance.Position = newVector2(x, y + height / 2 + 16);
                esp.distance.Color = esp.box.Color;
            end
        end
    else
        esp.box.Visible = false;
        esp.boxoutline.Visible = false;
        esp.tracer.Visible = false;
        esp.name.Visible = false;
        esp.distance.Visible = false;
    end
end

local function rainbowColorTransition()
    local t = tick() * 0.1
    return Color3.fromHSV(t % 1, 1, 1)
end

-- main
for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player);
    end
end

players.PlayerAdded:Connect(function(player)
    createEsp(player);
end);

players.PlayerRemoving:Connect(function(player)
    removeEsp(player);
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then
            continue;
        end

        if drawings and player ~= localPlayer then
            updateEsp(player, drawings);
            if settings.rainbowEnabled then
                local rainbowColor = rainbowColorTransition();
                drawings.box.Color = rainbowColor;
                drawings.tracer.Color = rainbowColor;
                drawings.name.Color = rainbowColor;
                drawings.distance.Color = rainbowColor;
            end
        end
    end
end)

-- GUI integration
local tab = DrRayLibrary.newTab("Esp Tab", "ImageIdHere")

tab.newToggle("Box Esp", "Draws a box around every player", true, function(toggleState)
    settings.boxESPEnabled = toggleState
end)

tab.newToggle("Tracers Esp", "Draws a line to every player", true, function(toggleState)
    settings.tracersEnabled = toggleState
end)

tab.newToggle("Distance Esp", "Displays the distance to every player", true, function(toggleState)
    settings.distanceESPEnabled = toggleState
end)

tab.newToggle("Name Esp", "Displays the name of every player", true, function(toggleState)
    settings.nameESPEnabled = toggleState
end)

tab.newToggle("Rainbow Esp", "Enables rainbow color transition for ESP", false, function(toggleState)
    settings.rainbowEnabled = toggleState
end)

local tab = DrRayLibrary.newTab("Misc Tab", "ImageIdHere")

tab.newButton("Change To The Strongest Hero", "Changes your character to the strongest hero", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Bald"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Hero Hunter", "Changes your character to Hero Hunter", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Hunter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Destructive Cyborg", "Changes your character to Destructive Cyborg", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Cyborg"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Deadly Ninja", "Changes your character to Deadly Ninja", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Ninja"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Brutal Demon", "Changes your character to Brutal Demon", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Batter"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Blade Master", "Changes your character to Blade Master", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Blade"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

tab.newButton("Change to Wild Psychic", "Changes your character to Wild Psychic", function()
    local args = {
        [1] = {
            ["Goal"] = "Change Character",
            ["Character"] = "Esper"
        }
    }
    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
end)

-- Button for Rejoin
tab.newButton("Rejoin", "Rejoin the game", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end)

-- Button for Serverhop
tab.newButton("Serverhop", "Hop to another server", function()
    local ts = game:GetService("TeleportService")
    local http = game:GetService("HttpService")
    local servers = {}
    local function listServers(cursor)
        local url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
        if cursor then
            url = url .. "&cursor=" .. cursor
        end
        local response = game:HttpGet(url)
        return http:JSONDecode(response)
    end
    local serverData = listServers()
    for _, server in ipairs(serverData.data) do
        if server.playing < server.maxPlayers then
            table.insert(servers, server.id)
        end
    end
    if #servers > 0 then
        ts:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], game.Players.LocalPlayer)
    else
        warn("No available servers found.")
    end
end)
